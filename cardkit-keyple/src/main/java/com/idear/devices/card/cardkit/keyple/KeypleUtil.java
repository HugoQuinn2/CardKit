package com.idear.devices.card.cardkit.keyple;

import com.idear.devices.card.cardkit.core.datamodel.calypso.Calypso;
import com.idear.devices.card.cardkit.core.datamodel.calypso.CalypsoCardCDMX;
import com.idear.devices.card.cardkit.core.datamodel.calypso.constant.*;
import com.idear.devices.card.cardkit.core.datamodel.calypso.file.*;
import com.idear.devices.card.cardkit.core.datamodel.date.CompactDate;
import com.idear.devices.card.cardkit.core.datamodel.date.CompactTime;
import com.idear.devices.card.cardkit.core.datamodel.date.DateTimeReal;
import com.idear.devices.card.cardkit.core.datamodel.date.ReverseDate;
import com.idear.devices.card.cardkit.core.exception.CardException;
import com.idear.devices.card.cardkit.core.exception.SamException;
import com.idear.devices.card.cardkit.core.io.card.file.File;
import com.idear.devices.card.cardkit.core.io.reader.GenericApduResponse;
import com.idear.devices.card.cardkit.core.utils.BitUtil;
import com.idear.devices.card.cardkit.core.utils.ByteUtils;
import lombok.extern.slf4j.Slf4j;
import org.eclipse.keyple.card.calypso.CalypsoExtensionService;
import org.eclipse.keyple.card.calypso.crypto.legacysam.LegacySamExtensionService;
import org.eclipse.keyple.card.calypso.crypto.legacysam.LegacySamUtil;
import org.eclipse.keyple.card.generic.CardTransactionManager;
import org.eclipse.keyple.card.generic.TransactionException;
import org.eclipse.keyple.core.service.ObservablePlugin;
import org.eclipse.keyple.core.service.SmartCardService;
import org.eclipse.keyple.core.service.SmartCardServiceProvider;
import org.eclipse.keyple.core.util.ByteArrayUtil;
import org.eclipse.keyple.core.util.HexUtil;
import org.eclipse.keyple.plugin.pcsc.PcscPluginFactoryBuilder;
import org.eclipse.keyple.plugin.pcsc.PcscReader;
import org.eclipse.keyple.plugin.pcsc.PcscSupportedContactProtocol;
import org.eclipse.keyple.plugin.pcsc.PcscSupportedContactlessProtocol;
import org.eclipse.keypop.calypso.card.CalypsoCardApiFactory;
import org.eclipse.keypop.calypso.card.PutDataTag;
import org.eclipse.keypop.calypso.card.WriteAccessLevel;
import org.eclipse.keypop.calypso.card.card.CalypsoCard;
import org.eclipse.keypop.calypso.card.card.CalypsoCardSelectionExtension;
import org.eclipse.keypop.calypso.card.card.ElementaryFile;
import org.eclipse.keypop.calypso.card.transaction.*;
import org.eclipse.keypop.calypso.card.transaction.FreeTransactionManager;
import org.eclipse.keypop.calypso.card.transaction.spi.SymmetricCryptoCardTransactionManagerFactory;
import org.eclipse.keypop.calypso.crypto.legacysam.GetDataTag;
import org.eclipse.keypop.calypso.crypto.legacysam.LegacySamApiFactory;
import org.eclipse.keypop.calypso.crypto.legacysam.sam.LegacySam;
import org.eclipse.keypop.calypso.crypto.legacysam.sam.LegacySamSelectionExtension;
import org.eclipse.keypop.calypso.crypto.legacysam.transaction.*;
import org.eclipse.keypop.reader.CardReader;
import org.eclipse.keypop.reader.ConfigurableCardReader;
import org.eclipse.keypop.reader.ReaderApiFactory;
import org.eclipse.keypop.reader.selection.*;
import org.eclipse.keypop.reader.selection.spi.SmartCard;

import java.time.LocalDate;
import java.util.*;

/**
 * Utility class providing helper methods to interact with Calypso cards and
 * Legacy SAM modules using the Keyple framework.
 * <p>
 * This class centralizes common operations such as:
 * <ul>
 *   <li>Reader discovery and selection</li>
 *   <li>Calypso card and SAM selection</li>
 *   <li>Secure session management</li>
 *   <li>File read/write operations</li>
 *   <li>Stored value debit/reload</li>
 *   <li>Event logging and transaction signature computation</li>
 * </ul>
 * <p>
 * All methods are static and the class is not intended to be instantiated.
 */
@Slf4j
public abstract class KeypleUtil {

    public static final SmartCardService SMART_CARD_SERVICE = SmartCardServiceProvider.getService();
    public static final ReaderApiFactory READER_API_FACTORY = SMART_CARD_SERVICE.getReaderApiFactory();
    public static final CalypsoExtensionService CALYPSO_EXTENSION_SERVICE = CalypsoExtensionService.getInstance();
    public static final CalypsoCardApiFactory CALYPSO_CARD_API_FACTORY = CALYPSO_EXTENSION_SERVICE.getCalypsoCardApiFactory();
    public static final LegacySamApiFactory LEGACY_SAM_API_FACTORY = LegacySamExtensionService.getInstance().getLegacySamApiFactory();

    public static final ObservablePlugin PLUGIN = (ObservablePlugin) SMART_CARD_SERVICE.registerPlugin(
            PcscPluginFactoryBuilder.builder().setCardMonitoringCycleDuration(5).build());

    /**
     * Returns the first card reader whose name matches the given regular expression.
     *
     * @param matchName a regular expression used to match the reader name
     * @return the matching {@link CardReader}
     * @throws RuntimeException if no readers are available or none match the pattern
     */
    public static CardReader getCardReaderMatchingName(
            String matchName,
            boolean isContactless) {
        CardReader reader = PLUGIN.getReaders().stream()
                .filter(r -> r.getName().matches(matchName))
                .findFirst()
                .orElse(null);

        if (reader == null)
            throw new IllegalStateException("Card reader is null");

        PcscReader pcscReader = PLUGIN
                .getReaderExtension(PcscReader.class, reader.getName())
                .setContactless(isContactless)
                .setSharingMode(PcscReader.SharingMode.SHARED);

        if (isContactless) {
            pcscReader.setIsoProtocol(PcscReader.IsoProtocol.T1);

            ((ConfigurableCardReader) reader).activateProtocol(
                    PcscSupportedContactlessProtocol.ISO_14443_4.name(),
                    "ISO_14443_4_CARD");
        } else {
            pcscReader.setIsoProtocol(PcscReader.IsoProtocol.ANY);

            ((ConfigurableCardReader) reader).activateProtocol(
                    PcscSupportedContactProtocol.ISO_7816_3_T0.name(),
                    "ISO_7816_3_T0");
        }
        return reader;
    }

    /**
     * Selects a Calypso card application on the given reader using the provided AID.
     *
     * @param cardReader the reader where the card is inserted
     * @param aid the application identifier (AID)
     * @return the selected {@link CalypsoCard}
     * @throws IllegalStateException if the application selection fails
     */
    public static CalypsoCard selectCard(
            CardReader cardReader,
            String aid) {

        CardSelectionManager cardSelectionManager = READER_API_FACTORY.createCardSelectionManager();
        CalypsoCardSelectionExtension calypsoCardSelection = CALYPSO_CARD_API_FACTORY
                .createCalypsoCardSelectionExtension()
                .acceptInvalidatedCard();

        cardSelectionManager.prepareSelection(
                READER_API_FACTORY.createIsoCardSelector()
                        .filterByDfName(aid),
                calypsoCardSelection);

        SmartCard smartCard;

        smartCard = cardSelectionManager
                .processCardSelectionScenario(cardReader)
                .getActiveSmartCard();

        if (smartCard == null)
            throw new IllegalStateException("The selection of the application " + aid + " failed.");

        return  (CalypsoCard) smartCard;
    }

    /**
     * Selects a Legacy SAM card from the given reader and unlocks it if required.
     *
     * @param samReader the reader hosting the SAM
     * @param lockSecret the unlock secret (may be {@code null})
     * @return the selected {@link LegacySam}
     * @throws SamException if the SAM cannot be selected or unlocked
     */
    public static LegacySam selectAndUnlockSam(
            CardReader samReader,
            String lockSecret) {

        SMART_CARD_SERVICE.checkCardExtension(CALYPSO_EXTENSION_SERVICE);

        // Create a SAM selection manager.
        CardSelectionManager samSelectionManager = READER_API_FACTORY.createCardSelectionManager();

        // Create a card selector without filter
        CardSelector<BasicCardSelector> samCardSelector = READER_API_FACTORY.createBasicCardSelector();

        // Create a SAM selection
        LegacySamSelectionExtension samSelection = LEGACY_SAM_API_FACTORY
                .createLegacySamSelectionExtension()
                .prepareReadAllCountersStatus();

        // Set lock secret
        if (lockSecret != null)
            samSelection.setUnlockData(lockSecret);

        // Prepare SAM selection
        samSelectionManager.prepareSelection(samCardSelector, samSelection);

        // Get SAM
        LegacySam sam = null;
        try {
            sam = (LegacySam) samSelectionManager
                    .processCardSelectionScenario(samReader)
                    .getActiveSmartCard();
        } catch (Exception ex) {
            throw new SamException("Calypso SAM selection failed in reader %s.", samReader.getName());
        }

        if (sam == null)
            throw new SamException("No Calypso SAM in reader %s.", samReader.getName());

        return sam;
    }

    /**
     * Initializes symmetric cryptographic security settings using a Legacy SAM.
     *
     * @param samReader the reader hosting the SAM
     * @param sam the selected Legacy SAM
     * @return a configured {@link SymmetricCryptoSecuritySetting}
     */
    public static SymmetricCryptoSecuritySetting startSymmetricSecuritySettings(
            CardReader samReader,
            LegacySam sam) {
        SymmetricCryptoCardTransactionManagerFactory symmetricCryptoCardTransactionManagerFactory =
                LEGACY_SAM_API_FACTORY
                        .createSymmetricCryptoCardTransactionManagerFactory(
                                samReader, sam);

        return CALYPSO_CARD_API_FACTORY
                .createSymmetricCryptoSecuritySetting(symmetricCryptoCardTransactionManagerFactory)
                .enableSvLoadAndDebitLog()
                .assignDefaultKif(WriteAccessLevel.PERSONALIZATION, (byte) 0x21)
                .assignDefaultKif(WriteAccessLevel.LOAD, (byte) 0x27)
                .assignDefaultKif(WriteAccessLevel.DEBIT, (byte) 0x30);
    }

    /**
     * Reads a full record from a card file.
     *
     * @param ctm the transaction manager
     * @param calypsoCard the Calypso card
     * @param writeAccessLevel the access level to use
     * @param fileId the file identifier (SFI)
     * @param record the record number
     * @return the raw file content
     * @throws CardException if the read operation fails
     */
    public static byte[] readCardFile(
            SecureRegularModeTransactionManager ctm,
            CalypsoCard calypsoCard,
            WriteAccessLevel writeAccessLevel,
            byte fileId,
            int record) {
        try {
            ctm
//                    .prepareOpenSecureSession(writeAccessLevel)
                    .prepareReadRecord(fileId, record)
                    .prepareSvGet(SvOperation.DEBIT, SvAction.DO)
//                    .prepareCloseSecureSession()
                    .processCommands(ChannelControl.KEEP_OPEN);
        } catch (Exception e) {
            throw new CardException(e.getMessage());
        }

        ElementaryFile elementaryFile = calypsoCard.getFileBySfi(fileId);

        if (elementaryFile == null)
            throw new CardException("The file %s could not be read", fileId);

        return elementaryFile.getData().getContent();
    }

    public static Map<Byte, byte[]> readCardFile(
            SecureRegularModeTransactionManager ctm,
            CalypsoCard calypsoCard,
            WriteAccessLevel writeAccessLevel,
            Map<Byte, Integer> fileAndRecord,
            ChannelControl channelControl) {
        Map<Byte, byte[]> filesData = new HashMap<>();
//        ctm.prepareOpenSecureSession(writeAccessLevel);

        for (Map.Entry<Byte, Integer> entry : fileAndRecord.entrySet()) {
            ctm.prepareReadRecord(entry.getKey(), entry.getValue());
        }

        ctm
                .prepareSvGet(SvOperation.DEBIT, SvAction.DO)
//                .prepareCloseSecureSession()
                .processCommands(channelControl);

        for (Map.Entry<Byte, Integer> entry : fileAndRecord.entrySet()) {
            ElementaryFile elementaryFile = calypsoCard.getFileBySfi(entry.getKey());
            if (elementaryFile != null)
                filesData.put(entry.getKey(), elementaryFile.getData().getContent());
        }

        return filesData;
    }

    /**
     * Reads a portion of records from a card file.
     *
     * @param ctm the transaction manager
     * @param calypsoCard the Calypso card
     * @param writeAccessLevel the access level to use
     * @param fileId the file identifier (SFI)
     * @param fromRecord starting record number
     * @param toRecord ending record number
     * @param offset byte offset within the record
     * @param bytesToRead number of bytes to read
     * @return a map of record numbers to record data
     * @throws CardException if the operation fails
     */
    public static SortedMap<Integer, byte[]> readCardPartially(
            SecureRegularModeTransactionManager ctm,
            CalypsoCard calypsoCard,
            WriteAccessLevel writeAccessLevel,
            byte fileId,
            int fromRecord,
            int toRecord,
            int offset,
            int bytesToRead) {
        try {
            ctm
//                    .prepareOpenSecureSession(writeAccessLevel)
                    .prepareSvGet(SvOperation.DEBIT, SvAction.DO)
                    .prepareReadRecordsPartially(
                            fileId,
                            fromRecord,
                            toRecord,
                            offset,
                            bytesToRead)
//                    .prepareCloseSecureSession()
                    .processCommands(ChannelControl.KEEP_OPEN);
        } catch (Exception e) {
            throw new CardException(e.getMessage());
        }

        return calypsoCard.getFileBySfi(fileId)
                .getData()
                .getAllRecordsContent();
    }

    /**
     * Appends a new record to a card file.
     *
     * @param ctm the transaction manager
     * @param fileId the file identifier
     * @param fileData the data to append
     * @param channelControl the channel control behavior
     * @throws CardException if the append operation fails
     */
    public static void appendEditCardFile(
            SecureRegularModeTransactionManager ctm,
            byte fileId,
            byte[] fileData,
            ChannelControl channelControl,
            boolean isCloseSession) {
        try {
            if (isCloseSession)
                ctm.prepareAppendRecord(fileId, fileData)
                        .prepareCloseSecureSession()
                        .processCommands(channelControl);
            else
                ctm.prepareAppendRecord(fileId, fileData)
                        .processCommands(channelControl);

        } catch (Exception e) {
            throw new CardException(e.getMessage());
        }
    }

    /**
     * Appends a new record to a card file, with default channel control {@link ChannelControl#KEEP_OPEN}
     *
     * @param ctm the transaction manager
     * @param fileId the file identifier
     * @param fileData the data to append
     * @throws CardException if the append operation fails
     */
    public static void appendEditCardFile(
            SecureRegularModeTransactionManager ctm,
            byte fileId,
            byte[] fileData,
            boolean isCloseSession) {
        appendEditCardFile(ctm, fileId, fileData, ChannelControl.KEEP_OPEN, isCloseSession);
    }

    /**
     * Updates an existing record in a card file.
     *
     * @param ctm the transaction manager
     * @param fileId the file identifier
     * @param record the record number
     * @param data the new record data
     * @param channelControl the channel control behavior
     * @throws CardException if the update fails
     */
    public static void editCardFile(
            SecureRegularModeTransactionManager ctm,
            byte fileId,
            int record,
            byte[] data,
            ChannelControl channelControl,
            boolean isCloseSession) {
        try {
            ctm.prepareUpdateRecord(fileId, record, data);
            if (isCloseSession)
                ctm.prepareCloseSecureSession();
            ctm.processCommands(channelControl);
        } catch (Exception e) {
            throw new CardException("Error updating file card: ", e.getMessage());
        }
    }

    /**
     * Saves a transaction event on the card and builds the corresponding event data.
     *
     * @param ctm the transaction manager
     * @param calypsoCardCDMX the CDMX-specific Calypso card model
     * @param calypsoCard the Calypso card
     * @param keypleCalypsoSamReader the SAM reader wrapper
     * @param event the event to save
     * @param contract the related contract
     * @param initBalance the balance before the transaction
     * @param provider the service provider identifier
     * @return the generated {@link TransactionDataEvent}
     */
    public static TransactionDataEvent saveEvent(
            SecureRegularModeTransactionManager ctm,
            CalypsoCardCDMX calypsoCardCDMX,
            CalypsoCard calypsoCard,
            KeypleCalypsoSamReader keypleCalypsoSamReader,
            Event event,
            Contract contract,
            int initBalance,
            int provider,
            ChannelControl channelControl) {
        String mac = "";
        TransactionType transactionType = event.getTransactionType().decode(TransactionType.RFU);
        if (transactionType.isSigned())
            mac = computeTransactionSignature(keypleCalypsoSamReader, event, calypsoCardCDMX, initBalance, provider);

        Logs logs = readCardLogs(ctm, calypsoCard);

        if (transactionType.isWritten())
            try {
                appendEditCardFile(ctm, Calypso.EVENT_FILE, event.unparse(), channelControl, true);
            } catch (Exception ignored) {
                System.out.println(ignored);
            }

        return TransactionDataEvent
                .builder()
                .mac(mac)
                .debitLog(logs.getDebitLog())
                .loadLog(logs.getLoadLog())
                .event(event)
                .contract(contract)
                .profile(calypsoCardCDMX.getEnvironment().getProfile().getValue())
                .transactionAmount(event.getAmount())
                .balanceBeforeTransaction(initBalance)
                .locationCode(event.getLocationId())
                .build();
    }

    /**
     * Saves a transaction event on the card and builds the corresponding event data.
     *
     * @param ctm the transaction manager
     * @param calypsoCardCDMX the CDMX-specific Calypso card model
     * @param calypsoCard the Calypso card
     * @param keypleCalypsoSamReader the SAM reader wrapper
     * @param event the event to save
     * @param contract the related contract
     * @param initBalance the balance before the transaction
     * @param provider the service provider identifier
     * @return the generated {@link TransactionDataEvent}
     */
    public static TransactionDataEvent saveEvent(
            SecureRegularModeTransactionManager ctm,
            CalypsoCardCDMX calypsoCardCDMX,
            CalypsoCard calypsoCard,
            KeypleCalypsoSamReader keypleCalypsoSamReader,
            Event event,
            Contract contract,
            int initBalance,
            int provider) {
        return saveEvent(ctm, calypsoCardCDMX, calypsoCard, keypleCalypsoSamReader, event, contract, initBalance, provider, ChannelControl.KEEP_OPEN);
    }

    /**
     * Computes a transaction MAC using the SAM.
     *
     * @param keypleCalypsoSamReader the SAM reader wrapper
     * @param eventType the transaction type
     * @param transactionTimestamp the transaction timestamp
     * @param transactionAmount the transaction amount
     * @param terminalLocation the terminal location code
     * @param cardType the card product type
     * @param cardSerialHex the card serial number (hexadecimal)
     * @param prevSvBalance the previous stored value balance
     * @param svProvider the stored value provider
     * @return the computed MAC as a hexadecimal string
     */
    public static String computeTransactionSignature(
            KeypleCalypsoSamReader keypleCalypsoSamReader,
            int eventType,
            int transactionTimestamp,
            int transactionAmount,
            int terminalLocation,
            int cardType,
            String cardSerialHex,
            int prevSvBalance,
            int svProvider) {
        BitUtil bit = new BitUtil(0x20 * 8);
        bit.setNextInteger(eventType, 8);
        bit.setNextInteger(transactionTimestamp, 32);
        bit.setNextInteger(Math.abs(transactionAmount), 32);
        bit.setNextInteger(terminalLocation, 32);
        bit.setNextInteger(cardType, 8);
        bit.setNextHexaString(cardSerialHex, 64);
        bit.setNextInteger(prevSvBalance, 32);
        bit.setNextInteger(svProvider, 8);
        bit.setNextInteger(0, 16);
        bit.setNextInteger(0, 24);

        GenericApduResponse response = digestMacCompute(
                keypleCalypsoSamReader.getGenericSamTransactionManager(),
                (byte) 0xEB,
                (byte) 0xC0,
                bit.getData());

        return HexUtil.toHex(response.getDataOut());
    }

    /**
     * Computes a transaction MAC using the SAM.
     *
     * @param keypleCalypsoSamReader the SAM reader wrapper
     * @param event the event to use
     * @param calypsoCardCDMX the calypso card data to use
     * @param prevSvBalance the previous stored value balance
     * @param svProvider the stored value provider
     * @return the computed MAC as a hexadecimal string
     */
    public static String computeTransactionSignature(
            KeypleCalypsoSamReader keypleCalypsoSamReader,
            Event event,
            CalypsoCardCDMX calypsoCardCDMX,
            int prevSvBalance,
            int svProvider) {
        return computeTransactionSignature(
                keypleCalypsoSamReader,
                event.getTransactionType().getValue(),
                DateTimeReal.now().getValue(),
                event.getAmount(),
                event.getLocationId().getValue(),
                calypsoCardCDMX.getCalypsoProduct().getValue(),
                calypsoCardCDMX.getSerial(),
                prevSvBalance,
                svProvider
        );
    }

    /**
     * Sends a DIGEST MAC COMPUTE command to the SAM.
     *
     * @param samGenericTransactionManager the SAM transaction manager
     * @param kif the key identifier
     * @param kvc the key version
     * @param data the data to authenticate
     * @return a {@link GenericApduResponse} containing the MAC and status word
     */
    public static GenericApduResponse digestMacCompute(
            CardTransactionManager samGenericTransactionManager,
            byte kif,
            byte kvc,
            byte[] data) {
        byte cla = (byte) 0x80;
        byte ins = (byte) 0x8F;
        byte p1  = (byte) 0x00;
        byte p2  = (byte) 0x00;
        byte lc  = (byte) 0x22;

        byte[] head = {cla, ins, p1, p2, lc, kif, kvc};
        byte[] apdu = new byte[head.length + data.length];
        System.arraycopy(head, 0, apdu, 0, head.length);
        System.arraycopy(data, 0, apdu, head.length, data.length);

        byte[] mac;
        String sw = "";
        try {
            byte[] response = samGenericTransactionManager
                    .prepareApdu(apdu)
                    .processApdusToByteArrays(org.eclipse.keyple.card.generic.ChannelControl.KEEP_OPEN)
                    .get(0);
            mac = Arrays.copyOfRange(response, 0, response.length - 2);
            sw = org.eclipse.keyple.core.util.HexUtil.toHex(Arrays.copyOfRange(
                    response, response.length-2, response.length));
        } catch (TransactionException e) {
            mac = new byte[0];
        }
        return new GenericApduResponse(mac, sw);
    }

    /**
     * Reads the debit and load logs from the card.
     *
     * @param ctm the transaction manager
     * @param calypsoCard the Calypso card
     * @return a {@link Logs} object containing debit and load logs
     */
    public static Logs readCardLogs(
            SecureRegularModeTransactionManager ctm,
            CalypsoCard calypsoCard) {
//        ctm
//                .prepareOpenSecureSession(WriteAccessLevel.DEBIT)
//                .prepareSvGet(SvOperation.DEBIT, SvAction.DO)
//                .prepareCloseSecureSession()
//                .processCommands(ChannelControl.KEEP_OPEN);

        Logs logs = new Logs();
        logs.setDebitLog(new DebitLog().parse(calypsoCard.getSvDebitLogLastRecord()));
        logs.setLoadLog(new LoadLog().parse(calypsoCard.getSvLoadLogRecord()));

        return logs;
    }

    /**
     * Performs a debit operation on the card stored value.
     *
     * @param ctm the transaction manager
     * @param amount the amount to debit
     * @param channelControl the channel control
     */
    public static void performDebit(
            SecureRegularModeTransactionManager ctm,
            int amount,
            ChannelControl channelControl) {
        ctm
//                .prepareOpenSecureSession(WriteAccessLevel.DEBIT)
                .prepareSvGet(SvOperation.DEBIT, SvAction.DO)
                .prepareSvDebit(
                        amount,
                        CompactDate.now().toBytes(),
                        CompactTime.now().toBytes())
//                .prepareCloseSecureSession()
                .processCommands(channelControl);
    }

    /**
     * Performs a debit operation on the card stored value.
     *
     * @param ctm the transaction manager
     * @param amount the amount to debit
     */
    public static void performDebit(
            SecureRegularModeTransactionManager ctm,
            int amount) {
        performDebit(ctm, amount, ChannelControl.KEEP_OPEN);
    }

    /**
     * Rehabilitates a previously invalidated card.
     *
     * @param ctm the transaction manager
     */
    public static void rehabilitateCard(
            SecureRegularModeTransactionManager ctm) {
        ctm
//                .prepareOpenSecureSession(WriteAccessLevel.PERSONALIZATION)
                .prepareRehabilitate()
//                .prepareCloseSecureSession()
                .processCommands(ChannelControl.KEEP_OPEN);
    }

    /**
     * Invalidates the card.
     *
     * @param ctm the transaction manager
     */
    public static void invalidateCard(
            SecureRegularModeTransactionManager ctm) {
        invalidateCard(ctm, ChannelControl.KEEP_OPEN);
    }

    public static void invalidateCard(
            SecureRegularModeTransactionManager ctm, ChannelControl channelControl) {
        ctm
//                .prepareOpenSecureSession(WriteAccessLevel.DEBIT)
                .prepareInvalidate()
//                .prepareCloseSecureSession()
                .processCommands(channelControl);
    }

    /**
     * Increases or decreases the balance card
     *
     * @param ctm the transaction manager
     * @param amount the amount
     */
    public static void reloadCard(
            SecureRegularModeTransactionManager ctm,
            int amount) {
        ctm
//                .prepareOpenSecureSession(WriteAccessLevel.LOAD)
                .prepareSvGet(SvOperation.RELOAD, SvAction.DO)
                .prepareSvReload(
                        amount,
                        CompactDate.now().toBytes(),
                        CompactTime.now().toBytes(),
                        ByteUtils.extractBytes(0, 2))
//                .prepareCloseSecureSession()
                .processCommands(ChannelControl.KEEP_OPEN);
    }

    /**
     * Builds the data structure required to compute a traceable signature for a contract.
     *
     * @param fullSerial the full card serial number
     * @param contract the contract to sign
     * @return a {@link TraceableSignatureComputationData} instance
     */
    public static TraceableSignatureComputationData buildSignatureComputationData(
            byte[] fullSerial,
            Contract contract) {
        return LEGACY_SAM_API_FACTORY
                .createTraceableSignatureComputationData()
                .withSamTraceabilityMode(
                        0xD0,
                        SamTraceabilityMode.FULL_SERIAL_NUMBER)
                .setSignatureSize(3)
                .setData(buildSignatureData(fullSerial, contract), (byte) 0x2C, (byte) 0xC4);
    }

    /**
     * Build the signature contract data with serial card
     *
     * @param fullSerial the serial card
     * @param contract the contract
     * @return the signature data
     */
    public static byte[] buildSignatureData(
            byte[] fullSerial,
            Contract contract) {
        byte[] signatureData = new byte[34];
        System.arraycopy(fullSerial, 0, signatureData, 0, 8);

        byte[] _contract = contract.unparse();
        System.arraycopy(_contract, 0, signatureData, 8, _contract.length - 3);

        signatureData[9] = 0; // ContractStatus
        signatureData[10] = 0; // ContractRfu and ContractValidityStartDate MSb
        signatureData[11] = 0; // ContractValidityStartDate LSb

        return signatureData;
    }

    /**
     * Prepares and renews a contract by computing and applying a SAM signature.
     *
     * @param ctm the transaction manager
     * @param fullSerial the full card serial number
     * @param contract the existing contract
     * @param provider the service provider identifier
     * @param startDate the new contract start date
     * @param duration the contract duration
     * @return the renewed {@link Contract}
     */
    public static Contract setupRenewContract(
            SecureRegularModeTransactionManager ctm,
            byte[] fullSerial,
            Contract contract,
            int provider,
            ReverseDate startDate,
            int duration) {

        Contract wEfContract = new Contract(contract.getId()).parse(contract.unparse());
        wEfContract.getVersion().setValue(Version.VERSION_3_3);
        wEfContract.setRfu(0);
        wEfContract.getStatus().setValue(0);
        wEfContract.setStartDate(ReverseDate.zero());
        wEfContract.setDuration(duration);
//        wEfContract.getNetwork().setValue(NetworkCode.CDMX);
        wEfContract.getProvider().setValue(provider);
//        wEfContract.getModality().setValue(Modality.MONOMODAL);
        wEfContract.getTariff().setValue(Tariff.STORED_VALUE);
        wEfContract.setJourneyInterChanges(1);
//        wEfContract.setSaleDate(CompactDate.now());
        wEfContract.setAuthKvc((byte) 0xC4 & 0xff);

        // Compute contract signature
        TraceableSignatureComputationData signatureData = buildSignatureComputationData(
                fullSerial,
                wEfContract);
        ctm.getCryptoExtension(CardTransactionLegacySamExtension.class)
                .prepareComputeSignature(signatureData);
        ctm.processCommands(ChannelControl.KEEP_OPEN);

        // Get signed contract
        int signature = ByteArrayUtil.extractInt(
                signatureData.getSignature(),
                0, 3, false);

        byte[] signedContract = Arrays.copyOfRange(
                signatureData.getSignedData(),
                fullSerial.length, signatureData.getSignedData().length);

        wEfContract.parse(signedContract);

        // Set signature independent fields
        wEfContract.setRfu(0);
        wEfContract.getStatus().setValue(ContractStatus.CONTRACT_PARTLY_USED);
        wEfContract.setStartDate(startDate);
        wEfContract.setAuthenticator(signature);
        wEfContract.update();

        return wEfContract;
    }

    /**
     * Creates a secure regular mode transaction manager for a Calypso card.
     *
     * @param cardReader the reader hosting the card
     * @param calypsoCard the selected Calypso card
     * @param symmetricCryptoSecuritySetting the security settings to apply
     * @return a {@link SecureRegularModeTransactionManager}
     */
    public static SecureRegularModeTransactionManager prepareCardTransactionManger(
            CardReader cardReader,
            CalypsoCard calypsoCard,
            SymmetricCryptoSecuritySetting symmetricCryptoSecuritySetting) {
        return CALYPSO_CARD_API_FACTORY
                .createSecureRegularModeTransactionManager(
                        cardReader,
                        calypsoCard,
                        symmetricCryptoSecuritySetting
                );
    }

    public static LegacySam selectLegacySamByProduct(
            CardReader samReader,
            LegacySam.ProductType productType) {
        // Create a SAM selection manager.
        CardSelectionManager samSelectionManager = KeypleUtil.READER_API_FACTORY.createCardSelectionManager();

        // Create a card selector without filer
        IsoCardSelector cardSelector =
                KeypleUtil.READER_API_FACTORY
                        .createIsoCardSelector()
                        .filterByPowerOnData(
                                LegacySamUtil.buildPowerOnDataFilter(productType, null));

        // Create a SAM selection using the Calypso card extension.
        samSelectionManager.prepareSelection(
                cardSelector, LEGACY_SAM_API_FACTORY.createLegacySamSelectionExtension());

        // SAM communication: run the selection scenario.
        CardSelectionResult samSelectionResult =
                samSelectionManager.processCardSelectionScenario(samReader);

        // Check the selection result.
        if (samSelectionResult.getActiveSmartCard() == null) {
            throw new SamException("The selection of the SAM failed, product " + productType + " required on sam");
        }

        return (LegacySam) samSelectionResult.getActiveSmartCard();
    }

    public static void cardSamKeyPair(
            CardReader cardReader,
            CardReader samReader,
            LegacySam legacySam,
            CalypsoCard calypsoCard,
            LocalDate startDate,
            LocalDate endDate) {
        FreeTransactionManager freeTransactionManager = CALYPSO_CARD_API_FACTORY
                .createFreeTransactionManager(cardReader, calypsoCard);
        try {
            freeTransactionManager
                    .prepareGenerateAsymmetricKeyPair()
                    .prepareGetData(org.eclipse.keypop.calypso.card.GetDataTag.CARD_PUBLIC_KEY)
                    .processCommands(ChannelControl.KEEP_OPEN);
        } catch (Exception e) {
            throw new CardException("Error making ECC key pair: " + e.getMessage());
        }

        LegacyCardCertificateComputationData cardCertificateComputationData =
                LEGACY_SAM_API_FACTORY
                        .createLegacyCardCertificateComputationData()
                        .setCardAid(calypsoCard.getDfName())
                        .setCardSerialNumber(calypsoCard.getApplicationSerialNumber())
                        .setStartDate(startDate)
                        .setEndDate(endDate)
                        .setCardStartupInfo(calypsoCard.getStartupInfoRawData());

        try {
            LEGACY_SAM_API_FACTORY
                    .createFreeTransactionManager(samReader, legacySam)
                    .prepareGetData(GetDataTag.CA_CERTIFICATE)
                    .prepareComputeCardCertificate(cardCertificateComputationData)
                    .processCommands();
        } catch (Exception e) {
            throw new SamException("Error generating PKI sam certification: " + e.getMessage());
        }

        try {
            CALYPSO_CARD_API_FACTORY
                    .createFreeTransactionManager(cardReader, calypsoCard)
                    .preparePutData(PutDataTag.CA_CERTIFICATE, legacySam.getCaCertificate())
                    .preparePutData(PutDataTag.CARD_CERTIFICATE, cardCertificateComputationData.getCertificate())
                    .processCommands(ChannelControl.KEEP_OPEN);
        } catch (Exception e) {
            throw new CardException("Error putting sam certification data on card: " + e.getMessage());
        }
    }

    public static void legacySamKeyPair(
            CardReader cardReader,
            CardReader samReader,
            LegacySam legacySam,
            CalypsoCard calypsoCard,
            LocalDate startDate,
            LocalDate endDate) {
        KeyPairContainer keyPairContainer = KeypleCalypsoSamReader.legacySamExtensionService.getLegacySamApiFactory().createKeyPairContainer();
        LegacyCardCertificateComputationData cardCertificateComputationData =
                LEGACY_SAM_API_FACTORY
                        .createLegacyCardCertificateComputationData()
                        .setCardAid(calypsoCard.getDfName())
                        .setCardSerialNumber(calypsoCard.getApplicationSerialNumber())
                        .setStartDate(startDate)
                        .setEndDate(endDate)
                        .setCardStartupInfo(calypsoCard.getStartupInfoRawData());

        try {
            LEGACY_SAM_API_FACTORY
                    .createFreeTransactionManager(samReader, legacySam)
                    .prepareGetData(GetDataTag.CA_CERTIFICATE)
                    .prepareGenerateCardAsymmetricKeyPair(keyPairContainer)
                    .prepareComputeCardCertificate(cardCertificateComputationData)
                    .processCommands();
        } catch (Exception e) {
            throw new SamException("Error generating PKI sam certification: " + e.getMessage());
        }

        try {
            CALYPSO_CARD_API_FACTORY
                    .createFreeTransactionManager(cardReader, calypsoCard)
                    .preparePutData(PutDataTag.CA_CERTIFICATE, legacySam.getCaCertificate())
                    .preparePutData(PutDataTag.CARD_KEY_PAIR, keyPairContainer.getKeyPair())
                    .preparePutData(PutDataTag.CA_CERTIFICATE, cardCertificateComputationData.getCertificate())
                    .processCommands(ChannelControl.KEEP_OPEN);
        }catch (Exception e) {
            throw new CardException("Error putting sam certification data on card: " + e.getMessage());
        }
    }

}
